/**
 * Test Loader Service Unit Tests
 */

import { Test, TestingModule } from '@nestjs/testing';
import { TestLoaderService } from './test-loader.service';
import * as fs from 'fs/promises';

// Mock dependencies
jest.mock('fs/promises');

describe('TestLoaderService', () => {
  let service: TestLoaderService;

  const mockTests: any[] = [
    {
      id: 'test-1',
      name: 'Test 1',
      description: 'Test description',
      testType: 'access-control',
      domain: 'identity',
      version: 1,
      versionHistory: [],
      createdAt: new Date(),
      updatedAt: new Date(),
    },
    {
      id: 'test-2',
      name: 'Test 2',
      description: 'Test description',
      testType: 'salesforce-config',
      domain: 'platform_config',
      platform: 'salesforce',
      check: 'test-check',
      severity: 'high',
      autoGenerated: false,
      configPath: '/path/to/config',
      expected: { passed: true },
      version: 1,
      versionHistory: [],
      createdAt: new Date(),
      updatedAt: new Date(),
    },
  ];

  const mockPolicies = [
    {
      id: 'policy-1',
      name: 'Test Policy',
      description: 'Policy description',
      effect: 'allow',
      rules: [
        {
          attribute: 'role',
          operator: 'equals',
          value: 'admin',
        },
      ],
    },
  ];

  const mockApplications: any[] = [
    {
      id: 'app-1',
      name: 'Test App',
      infrastructure: {},
      createdAt: new Date(),
      updatedAt: new Date(),
    },
  ];

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [TestLoaderService],
    }).compile();

    service = module.get<TestLoaderService>(TestLoaderService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('loadTests', () => {
    it('should load tests by IDs', async () => {
      // Arrange
      (fs.readFile as jest.Mock).mockResolvedValue(JSON.stringify(mockTests));

      // Act
      const result = await service.loadTests(['test-1', 'test-2']);

      // Assert
      expect(result).toHaveLength(2);
      expect(result[0].id).toBe('test-1');
      expect(result[1].id).toBe('test-2');
    });

    it('should filter tests by provided IDs', async () => {
      // Arrange
      (fs.readFile as jest.Mock).mockResolvedValue(JSON.stringify(mockTests));

      // Act
      const result = await service.loadTests(['test-1']);

      // Assert
      expect(result).toHaveLength(1);
      expect(result[0].id).toBe('test-1');
    });

    it('should return empty array when file does not exist', async () => {
      // Arrange
      const error = new Error('File not found');
      (error as any).code = 'ENOENT';
      (fs.readFile as jest.Mock).mockRejectedValue(error);

      // Act
      const result = await service.loadTests(['test-1']);

      // Assert
      expect(result).toEqual([]);
    });

    it('should return empty array when file is empty', async () => {
      // Arrange
      (fs.readFile as jest.Mock).mockResolvedValue('');

      // Act
      const result = await service.loadTests(['test-1']);

      // Assert
      expect(result).toEqual([]);
    });

    it('should normalize platform config tests', async () => {
      // Arrange
      (fs.readFile as jest.Mock).mockResolvedValue(JSON.stringify([mockTests[1]]));

      // Act
      const result = await service.loadTests(['test-2']);

      // Assert
      expect(result[0].testType).toBe('salesforce-config');
      expect((result[0] as any).platform).toBe('salesforce');
      expect((result[0] as any).check).toBe('test-check');
    });

    it('should throw error for non-ENOENT errors', async () => {
      // Arrange
      const error = new Error('Permission denied');
      (fs.readFile as jest.Mock).mockRejectedValue(error);

      // Act & Assert
      await expect(service.loadTests(['test-1'])).rejects.toThrow('Permission denied');
    });
  });

  describe('loadPolicy', () => {
    it('should load policy by ID', async () => {
      // Arrange
      (fs.readFile as jest.Mock).mockResolvedValue(JSON.stringify(mockPolicies));

      // Act
      const result = await service.loadPolicy('policy-1');

      // Assert
      expect(result.id).toBe('policy-1');
      expect(result.name).toBe('Test Policy');
      expect(result.effect).toBe('allow');
      expect(result.conditions).toHaveLength(1);
      expect(result.conditions[0].attribute).toBe('role');
    });

    it('should convert rules to conditions', async () => {
      // Arrange
      (fs.readFile as jest.Mock).mockResolvedValue(JSON.stringify(mockPolicies));

      // Act
      const result = await service.loadPolicy('policy-1');

      // Assert
      expect(result.conditions[0].attribute).toBe('role');
      expect(result.conditions[0].operator).toBe('equals');
      expect(result.conditions[0].value).toBe('admin');
    });

    it('should throw error when policy not found', async () => {
      // Arrange
      (fs.readFile as jest.Mock).mockResolvedValue(JSON.stringify(mockPolicies));

      // Act & Assert
      await expect(service.loadPolicy('non-existent')).rejects.toThrow('Policy non-existent not found');
    });

    it('should throw error when file does not exist', async () => {
      // Arrange
      const error = new Error('File not found');
      (error as any).code = 'ENOENT';
      (fs.readFile as jest.Mock).mockRejectedValue(error);

      // Act & Assert
      await expect(service.loadPolicy('policy-1')).rejects.toThrow('Policy policy-1 not found');
    });

    it('should use default values for missing fields', async () => {
      // Arrange
      const policyWithoutDefaults = [
        {
          id: 'policy-2',
          name: 'Policy 2',
        },
      ];
      (fs.readFile as jest.Mock).mockResolvedValue(JSON.stringify(policyWithoutDefaults));

      // Act
      const result = await service.loadPolicy('policy-2');

      // Assert
      expect(result.description).toBe('');
      expect(result.effect).toBe('allow');
      expect(result.priority).toBe(100);
      expect(result.conditions).toEqual([]);
    });
  });

  describe('loadApplication', () => {
    it('should load application by ID', async () => {
      // Arrange
      (fs.readFile as jest.Mock).mockResolvedValue(JSON.stringify(mockApplications));

      // Act
      const result = await service.loadApplication('app-1');

      // Assert
      expect(result.id).toBe('app-1');
      expect(result.name).toBe('Test App');
    });

    it('should throw error when application not found', async () => {
      // Arrange
      (fs.readFile as jest.Mock).mockResolvedValue(JSON.stringify(mockApplications));

      // Act & Assert
      await expect(service.loadApplication('non-existent')).rejects.toThrow('Application non-existent not found');
    });

    it('should throw error when file does not exist', async () => {
      // Arrange
      const error = new Error('File not found');
      (error as any).code = 'ENOENT';
      (fs.readFile as jest.Mock).mockRejectedValue(error);

      // Act & Assert
      await expect(service.loadApplication('app-1')).rejects.toThrow('Application app-1 not found');
    });

    it('should throw error when file is empty', async () => {
      // Arrange
      (fs.readFile as jest.Mock).mockResolvedValue('');

      // Act & Assert
      await expect(service.loadApplication('app-1')).rejects.toThrow('Application app-1 not found');
    });
  });
});
