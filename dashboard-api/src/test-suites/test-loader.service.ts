/**
 * Test Loader Service
 * 
 * Implements TestLoader interface for loading tests, policies, and applications
 * from the dashboard API data files.
 */

import { Injectable, Logger } from '@nestjs/common';
import * as fs from 'fs/promises';
import * as path from 'path';
import { TestLoader } from '../../../heimdall-framework/core/test-harness';
import { Test, PlatformConfigTest, ABACPolicy } from '../../../heimdall-framework/core/types';
import { Application } from '../applications/entities/application.entity';

@Injectable()
export class TestLoaderService implements TestLoader {
  private readonly logger = new Logger(TestLoaderService.name);
  private readonly testsFile = path.join(process.cwd(), 'data', 'tests.json');
  private readonly policiesFile = path.join(process.cwd(), 'data', 'policies.json');
  private readonly applicationsFile = path.join(process.cwd(), 'data', 'applications.json');

  async loadTests(testIds: string[]): Promise<Test[]> {
    try {
      const content = await fs.readFile(this.testsFile, 'utf-8');
      if (!content || content.trim() === '') {
        return [];
      }
      
      const allTests = JSON.parse(content);
      const tests = allTests.filter((t: any) => testIds.includes(t.id));
      
      // Convert to proper Test types
      return tests.map((t: any) => this.normalizeTest(t));
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        this.logger.warn('Tests file not found, returning empty array');
        return [];
      }
      this.logger.error('Error loading tests:', error);
      throw error;
    }
  }

  async loadPolicy(policyId: string): Promise<ABACPolicy> {
    try {
      const content = await fs.readFile(this.policiesFile, 'utf-8');
      if (!content || content.trim() === '') {
        throw new Error(`Policy ${policyId} not found`);
      }
      
      const policies = JSON.parse(content);
      const policy = policies.find((p: any) => p.id === policyId);
      
      if (!policy) {
        throw new Error(`Policy ${policyId} not found`);
      }
      
      // Convert to ABACPolicy format
      return {
        id: policy.id,
        name: policy.name,
        description: policy.description || '',
        effect: policy.effect || 'allow',
        conditions: policy.conditions || policy.rules?.map((r: any) => ({
          attribute: r.attribute || '',
          operator: r.operator || 'equals',
          value: r.value,
        })) || [],
        priority: policy.priority || 100,
      };
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        throw new Error(`Policy ${policyId} not found`);
      }
      this.logger.error('Error loading policy:', error);
      throw error;
    }
  }

  async loadApplication(applicationId: string): Promise<Application> {
    try {
      const content = await fs.readFile(this.applicationsFile, 'utf-8');
      if (!content || content.trim() === '') {
        throw new Error(`Application ${applicationId} not found`);
      }
      
      const applications = JSON.parse(content);
      const application = applications.find((a: any) => a.id === applicationId);
      
      if (!application) {
        throw new Error(`Application ${applicationId} not found`);
      }
      
      return application;
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        throw new Error(`Application ${applicationId} not found`);
      }
      this.logger.error('Error loading application:', error);
      throw error;
    }
  }

  /**
   * Normalize test data to proper Test type
   */
  private normalizeTest(test: any): Test {
    // Platform config tests need special handling
    const platformConfigTypes = [
      'salesforce-config',
      'salesforce-security',
      'elastic-config',
      'elastic-security',
      'k8s-security',
      'k8s-workload',
      'idp-compliance',
      'servicenow-config',
    ];

    if (platformConfigTypes.includes(test.testType)) {
      return {
        ...test,
        testType: test.testType,
        domain: test.domain || 'platform_config',
        platform: test.platform,
        check: test.check,
        severity: test.severity,
        autoGenerated: test.autoGenerated !== false,
        configPath: test.configPath,
        expected: test.expected || { passed: true },
      } as PlatformConfigTest;
    }

    // Return as-is for other test types
    return test as Test;
  }
}
