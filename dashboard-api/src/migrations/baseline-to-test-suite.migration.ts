/**
 * Migration: Convert Platform Baselines to Test Suites
 * 
 * This migration converts existing Platform Baselines into Test Suites
 * with PlatformConfigTest tests for each validation rule.
 */

import { v4 as uuidv4 } from 'uuid';
import { TestSuite, PlatformConfigTest, BaselineConfig, TestType, TestDomain } from '../../../heimdall-framework/core/types';

/**
 * Platform Baseline structure (from existing codebase)
 */
export interface PlatformBaseline {
  id: string;
  name: string;
  description: string;
  environment: string;
  version: string;
  platform: 'salesforce' | 'elastic' | 'idp-kubernetes' | 'servicenow';
  createdAt: Date | string;
  updatedAt: Date | string;
  createdBy?: string;
  tags?: string[];
  isActive: boolean;
  config: Record<string, any>; // Platform-specific config structure
  validationRules?: Array<{
    id?: string;
    name?: string;
    check: string;
    severity: 'critical' | 'high' | 'medium' | 'low';
    autoGenerated?: boolean;
    configPath?: string;
  }>;
}

/**
 * Platform Instance structure
 */
export interface PlatformInstance {
  id: string;
  name: string;
  platform: 'salesforce' | 'elastic' | 'idp-kubernetes' | 'servicenow';
  environment: string;
  connection: {
    endpoint?: string;
    credentials?: Record<string, any>; // Encrypted
  };
  baselineId: string; // References the baseline
  status?: 'healthy' | 'warnings' | 'errors';
  lastValidatedAt?: Date | string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
}

/**
 * Map platform to test type
 */
function mapPlatformToTestType(platform: string): TestType {
  const mapping: Record<string, TestType> = {
    'salesforce': 'salesforce-config',
    'elastic': 'elastic-config',
    'idp-kubernetes': 'idp-compliance',
    'servicenow': 'servicenow-config',
  };
  
  return mapping[platform] || 'salesforce-config';
}

/**
 * Map platform to domain
 */
function mapPlatformToDomain(platform: string): TestDomain {
  const mapping: Record<string, TestDomain> = {
    'salesforce': 'salesforce',
    'elastic': 'elastic',
    'idp-kubernetes': 'idp_platform',
    'servicenow': 'platform_config',
  };
  
  return mapping[platform] || 'platform_config';
}

/**
 * Generate validation rules from baseline config
 * This auto-generates rules based on the baseline configuration structure
 */
function generateValidationRulesFromConfig(
  config: Record<string, any>,
  platform: string,
  prefix: string = ''
): Array<{ check: string; severity: 'critical' | 'high' | 'medium' | 'low'; configPath: string }> {
  const rules: Array<{ check: string; severity: 'critical' | 'high' | 'medium' | 'low'; configPath: string }> = [];
  
  for (const [key, value] of Object.entries(config)) {
    const path = prefix ? `${prefix}.${key}` : key;
    
    if (value === null || value === undefined) {
      continue;
    }
    
    if (typeof value === 'boolean') {
      // Boolean values: check if enabled/true
      if (key.toLowerCase().includes('enabled') || key.toLowerCase().includes('required')) {
        rules.push({
          check: `${path} === true`,
          severity: value ? 'critical' : 'medium',
          configPath: path,
        });
      }
    } else if (typeof value === 'string') {
      // String values: check equality
      rules.push({
        check: `${path} === '${value}'`,
        severity: 'high',
        configPath: path,
      });
    } else if (typeof value === 'number') {
      // Number values: check equality
      rules.push({
        check: `${path} === ${value}`,
        severity: 'medium',
        configPath: path,
      });
    } else if (Array.isArray(value)) {
      // Array values: check length or contains
      if (value.length > 0) {
        rules.push({
          check: `${path}.length > 0`,
          severity: 'medium',
          configPath: path,
        });
      }
    } else if (typeof value === 'object') {
      // Recursively process nested objects
      rules.push(...generateValidationRulesFromConfig(value, platform, path));
    }
  }
  
  return rules;
}

/**
 * Convert Platform Baseline to Test Suite
 */
export async function migrateBaselineToTestSuite(
  baseline: PlatformBaseline,
  instanceId?: string
): Promise<{ testSuite: TestSuite; tests: PlatformConfigTest[] }> {
  const testType = mapPlatformToTestType(baseline.platform);
  const domain = mapPlatformToDomain(baseline.platform);
  
  // 1. Generate or use existing validation rules
  let validationRules = baseline.validationRules || [];
  
  // If no validation rules exist, auto-generate from config
  if (validationRules.length === 0 && baseline.config) {
    const autoRules = generateValidationRulesFromConfig(baseline.config, baseline.platform);
    validationRules = autoRules.map(rule => ({
      check: rule.check,
      severity: rule.severity,
      autoGenerated: true,
      configPath: rule.configPath,
    }));
  }
  
  // 2. Create Tests from validation rules
  const tests: PlatformConfigTest[] = validationRules.map((rule, index) => {
    const test: PlatformConfigTest = {
      id: rule.id || uuidv4(),
      name: rule.name || `Validation Rule ${index + 1}`,
      description: `Validates: ${rule.check}`,
      testType: testType,
      domain: domain,
      platform: baseline.platform,
      check: rule.check,
      severity: rule.severity,
      autoGenerated: rule.autoGenerated !== false, // Default to true if not specified
      configPath: rule.configPath,
      version: 1,
      createdAt: new Date(baseline.createdAt),
      updatedAt: new Date(baseline.updatedAt),
      createdBy: baseline.createdBy,
      expected: {
        passed: true,
        message: `Expected: ${rule.check}`,
      },
    };
    
    return test;
  });
  
  // 3. Create Baseline Config
  const baselineConfig: BaselineConfig = {
    platform: baseline.platform,
    environment: baseline.environment,
    config: baseline.config || {},
    version: baseline.version,
  };
  
  // 4. Create Test Suite
  const testSuite: TestSuite = {
    id: baseline.id, // Keep same ID for reference continuity
    name: baseline.name,
    application: instanceId || `platform-instance-${baseline.id}`, // Will be updated when instance is migrated
    team: baseline.createdBy || 'platform-team',
    testType: testType,
    domain: domain,
    testIds: tests.map(t => t.id),
    description: baseline.description,
    enabled: baseline.isActive,
    baselineConfig: baselineConfig,
    createdAt: new Date(baseline.createdAt),
    updatedAt: new Date(baseline.updatedAt),
    runtimeConfig: {
      environment: baseline.environment,
      // Platform instance connection will be added when instance is migrated
    },
  };
  
  return { testSuite, tests };
}

/**
 * Batch migrate multiple baselines
 */
export async function migrateBaselinesToTestSuites(
  baselines: PlatformBaseline[],
  instanceMap?: Map<string, string> // Maps baselineId -> instanceId
): Promise<{ testSuites: TestSuite[]; tests: PlatformConfigTest[] }> {
  const testSuites: TestSuite[] = [];
  const allTests: PlatformConfigTest[] = [];
  
  for (const baseline of baselines) {
    const instanceId = instanceMap?.get(baseline.id);
    const { testSuite, tests } = await migrateBaselineToTestSuite(baseline, instanceId);
    
    testSuites.push(testSuite);
    allTests.push(...tests);
  }
  
  return { testSuites, tests: allTests };
}
