/**
 * Platform Config Tester
 * 
 * Executes platform configuration tests by:
 * 1. Connecting to platform APIs
 * 2. Fetching current configuration
 * 3. Comparing against baseline configuration
 * 4. Evaluating validation rule expressions
 */

import { PlatformConfigTest, TestSuite, TestResult, BaselineConfig } from '../core/types';
import { PlatformConnector } from './platform-connectors/platform-connector.interface';
import { SalesforceConnector } from './platform-connectors/salesforce-connector';
import { ElasticConnector } from './platform-connectors/elastic-connector';
import { IDPKubernetesConnector } from './platform-connectors/idp-kubernetes-connector';
import { ServiceNowConnector } from './platform-connectors/servicenow-connector';

export interface PlatformConfigTestResult {
  passed: boolean;
  message: string;
  currentValue?: any;
  expectedValue?: any;
  configPath?: string;
  details?: Record<string, any>;
}

export class PlatformConfigTester {
  private connectors: Map<string, PlatformConnector> = new Map();

  constructor() {
    // Initialize platform connectors
    this.connectors.set('salesforce', new SalesforceConnector());
    this.connectors.set('elastic', new ElasticConnector());
    this.connectors.set('idp-kubernetes', new IDPKubernetesConnector());
    this.connectors.set('servicenow', new ServiceNowConnector());
  }

  /**
   * Execute a platform config test
   */
  async execute(
    test: PlatformConfigTest,
    suite: TestSuite,
    application?: any // Optional: Application with infrastructure
  ): Promise<TestResult> {
    try {
      // 1. Get platform instance connection from suite runtime config or application infrastructure
      let connection = suite.runtimeConfig?.platformInstance?.connection;
      
      // Fallback to application infrastructure if not in runtime config
      if (!connection && application?.infrastructure?.platformInstance) {
        connection = application.infrastructure.platformInstance.connection;
      }
      
      if (!connection) {
        throw new Error('Platform instance connection not found in test suite runtime config or application infrastructure');
      }

      // 2. Get baseline config from suite
      const baselineConfig = suite.baselineConfig;
      if (!baselineConfig) {
        throw new Error('Baseline configuration not found in test suite');
      }

      // 3. Connect to platform API
      const connector = this.connectors.get(test.platform);
      if (!connector) {
        throw new Error(`No connector available for platform: ${test.platform}`);
      }

      // 4. Fetch current configuration
      const currentConfig = await connector.getConfiguration(connection);

      // 5. Evaluate test check expression
      const result = this.evaluateCheck(
        test.check,
        currentConfig,
        baselineConfig.config,
        test.configPath
      );

      // 6. Return test result
      return {
        testType: test.testType,
        testName: test.name,
        passed: result.passed,
        details: {
          ...result,
          platform: test.platform,
          check: test.check,
          severity: test.severity,
          autoGenerated: test.autoGenerated,
        },
        timestamp: new Date(),
        testId: test.id,
        testVersion: test.version,
      };
    } catch (error: any) {
      return {
        testType: test.testType,
        testName: test.name,
        passed: false,
        details: {
          error: error.message,
          platform: test.platform,
        },
        timestamp: new Date(),
        testId: test.id,
        testVersion: test.version,
        error: error.message,
      };
    }
  }

  /**
   * Evaluate a check expression against current and baseline configs
   * 
   * Supports expressions like:
   * - "encryption.enabled === true"
   * - "sharingModel.defaultAccess === 'Private'"
   * - "fieldLevelSecurity.profiles.length > 0"
   */
  private evaluateCheck(
    check: string,
    currentConfig: Record<string, any>,
    baselineConfig: Record<string, any>,
    configPath?: string
  ): PlatformConfigTestResult {
    try {
      // Extract the path and expected value from the check expression
      const match = check.match(/^(.+?)\s*(===|!==|==|!=|>|<|>=|<=)\s*(.+)$/);
      
      if (!match) {
        // Try to evaluate as a simple boolean expression
        const value = this.getNestedValue(currentConfig, check);
        return {
          passed: Boolean(value),
          message: `Check: ${check}`,
          currentValue: value,
          configPath: configPath || check,
        };
      }

      const [, path, operator, expectedStr] = match;
      const trimmedPath = path.trim();
      const trimmedOperator = operator.trim();
      
      // Get current value from config
      const currentValue = this.getNestedValue(currentConfig, trimmedPath);
      
      // Parse expected value
      const expectedValue = this.parseValue(expectedStr.trim());

      // Compare based on operator
      let passed = false;
      switch (trimmedOperator) {
        case '===':
        case '==':
          passed = this.deepEqual(currentValue, expectedValue);
          break;
        case '!==':
        case '!=':
          passed = !this.deepEqual(currentValue, expectedValue);
          break;
        case '>':
          passed = Number(currentValue) > Number(expectedValue);
          break;
        case '<':
          passed = Number(currentValue) < Number(expectedValue);
          break;
        case '>=':
          passed = Number(currentValue) >= Number(expectedValue);
          break;
        case '<=':
          passed = Number(currentValue) <= Number(expectedValue);
          break;
        default:
          passed = false;
      }

      return {
        passed,
        message: passed
          ? `✓ ${trimmedPath} ${trimmedOperator} ${expectedStr}`
          : `✗ ${trimmedPath} (${currentValue}) ${trimmedOperator} ${expectedStr} (${expectedValue})`,
        currentValue,
        expectedValue,
        configPath: configPath || trimmedPath,
      };
    } catch (error: any) {
      return {
        passed: false,
        message: `Error evaluating check: ${error.message}`,
        configPath: configPath || check,
        details: { error: error.message },
      };
    }
  }

  /**
   * Get nested value from object using dot notation path
   */
  private getNestedValue(obj: any, path: string): any {
    const parts = path.split('.');
    let current = obj;
    
    for (const part of parts) {
      if (current === null || current === undefined) {
        return undefined;
      }
      current = current[part];
    }
    
    return current;
  }

  /**
   * Parse a value string (handles strings, numbers, booleans)
   */
  private parseValue(valueStr: string): any {
    // Remove quotes if present
    const trimmed = valueStr.trim();
    
    // Boolean
    if (trimmed === 'true') return true;
    if (trimmed === 'false') return false;
    
    // String (quoted)
    if ((trimmed.startsWith('"') && trimmed.endsWith('"')) ||
        (trimmed.startsWith("'") && trimmed.endsWith("'"))) {
      return trimmed.slice(1, -1);
    }
    
    // Number
    if (!isNaN(Number(trimmed))) {
      return Number(trimmed);
    }
    
    // Return as-is
    return trimmed;
  }

  /**
   * Deep equality check
   */
  private deepEqual(a: any, b: any): boolean {
    if (a === b) return true;
    if (a == null || b == null) return false;
    if (typeof a !== typeof b) return false;
    
    if (typeof a === 'object') {
      const keysA = Object.keys(a);
      const keysB = Object.keys(b);
      
      if (keysA.length !== keysB.length) return false;
      
      for (const key of keysA) {
        if (!keysB.includes(key)) return false;
        if (!this.deepEqual(a[key], b[key])) return false;
      }
      
      return true;
    }
    
    return false;
  }
}
