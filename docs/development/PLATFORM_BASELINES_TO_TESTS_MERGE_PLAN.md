# Platform Baselines to Tests Model Merge Plan

## Executive Summary

This plan outlines the migration of Platform Baselines into the unified Tests model, creating a consistent architecture where platform configuration validation uses the same patterns as access control testing.

**Key Insight:** Platform Baselines are conceptually Test Suites - they contain validation rules (Tests) that validate Platform Instances (Applications) against desired configurations (like Policies).

## Current State Analysis

### Platform Baselines (Current)
- **Platform Baseline**: Desired state configuration + validation rules
- **Platform Instance**: Live system to validate (like Application)
- **Validation Rules**: Individual checks (like Tests)
- **Validation**: Compare instance against baseline

### Tests Model (Current)
- **Test**: Atomic unit, validates Application against Policy (1:1)
- **Test Suite**: Collection of Tests (same testType)
- **Test Harness**: Collection of Test Suites (same domain)
- **Test Battery**: Collection of Test Harnesses

### Existing Test Types (Already Support Platforms)
```typescript
'salesforce-config' | 'salesforce-security'
'elastic-config' | 'elastic-security'
'k8s-security' | 'k8s-workload'
'idp-compliance'
```

## Conceptual Mapping

### High-Level Mapping
```
Platform Baseline     → Test Suite
Validation Rules      → Individual Tests
Platform Instance     → Application (being tested)
Baseline Config       → Test Suite metadata/runtime config
Validation Execution  → Test Suite execution
```

### Detailed Mapping

| Platform Baseline Concept | Tests Model Concept | Notes |
|---------------------------|---------------------|-------|
| `PlatformBaseline.id` | `TestSuite.id` | Direct mapping |
| `PlatformBaseline.name` | `TestSuite.name` | Direct mapping |
| `PlatformBaseline.platform` | `TestSuite.testType` | Maps to existing types (`salesforce-config`, etc.) |
| `PlatformBaseline.environment` | `TestSuite.runtimeConfig.environment` | Runtime config |
| `PlatformBaseline.config` | `TestSuite.runtimeConfig.baselineConfig` | Stored in runtime config |
| `PlatformBaseline.validationRules[]` | `TestSuite.testIds[]` | Each rule becomes a Test |
| `PlatformInstance` | `Application` | Platform instances become Applications |
| `PlatformInstance.connection` | `Application.infrastructure` | Connection info in infrastructure |
| `baselineId` reference | `TestSuite` reference | Instance references Test Suite |

## Migration Strategy

### Phase 1: Data Model Alignment (Week 1-2)

#### 1.1 Extend Test Types
**Goal:** Ensure all platform baseline types map to test types

**Actions:**
- [ ] Verify all platform types have corresponding test types:
  - `salesforce-config` ✅ (exists)
  - `elastic-config` ✅ (exists)
  - `idp-compliance` ✅ (exists)
  - `servicenow-config` → Add if missing
- [ ] Add new test types if needed
- [ ] Update `TestType` union type in all locations

**Files to Modify:**
- `heimdall-framework/core/types.ts`
- `dashboard-api/src/tests/dto/create-test.dto.ts`
- `dashboard-frontend/src/types/test.ts`

#### 1.2 Create Platform Config Test Type
**Goal:** Define test structure for platform configuration tests

**New Test Interface:**
```typescript
interface PlatformConfigTest extends BaseTest {
  testType: 'salesforce-config' | 'elastic-config' | 'idp-compliance' | ...;
  domain: 'platform-config';
  
  // Platform-specific test fields
  platform: 'salesforce' | 'elastic' | 'idp-kubernetes' | 'servicenow';
  check: string; // Validation rule expression
  severity: 'critical' | 'high' | 'medium' | 'low';
  autoGenerated: boolean; // True if derived from baseline config
  
  // Optional: Reference to baseline config section
  configPath?: string; // e.g., "encryption.fieldEncryption.enabled"
}
```

**Files to Create:**
- `dashboard-api/src/tests/entities/platform-config-test.entity.ts`
- `heimdall-framework/core/types.ts` (extend BaseTest)

#### 1.3 Extend Test Suite for Platform Configs
**Goal:** Add baseline config storage to Test Suite

**Extended Test Suite:**
```typescript
interface TestSuite {
  // ... existing fields ...
  
  // New fields for platform baselines
  baselineConfig?: {
    platform: string;
    environment: string;
    config: Record<string, any>; // Platform-specific config structure
    version: string;
  };
  
  // Runtime config already supports this, but make it explicit
  runtimeConfig?: RuntimeTestConfig & {
    platformInstance?: {
      connection: {
        endpoint?: string;
        credentials?: Record<string, any>; // Encrypted
      };
    };
  };
}
```

**Files to Modify:**
- `dashboard-api/src/test-suites/dto/create-test-suite.dto.ts`
- `heimdall-framework/core/types.ts`

### Phase 2: Migration Scripts (Week 2-3)

#### 2.1 Baseline to Test Suite Converter
**Goal:** Convert existing Platform Baselines to Test Suites

**Migration Script:**
```typescript
async function migrateBaselineToTestSuite(
  baseline: PlatformBaseline,
  instance: PlatformInstance
): Promise<TestSuite> {
  // 1. Create Tests from validation rules
  const tests = baseline.validationRules.map(rule => ({
    id: uuidv4(),
    name: rule.name || rule.check,
    testType: mapPlatformToTestType(baseline.platform),
    domain: 'platform-config',
    platform: baseline.platform,
    check: rule.check,
    severity: rule.severity,
    autoGenerated: rule.autoGenerated,
    // ... other BaseTest fields
  }));
  
  // 2. Create Test Suite
  const testSuite: TestSuite = {
    id: baseline.id,
    name: baseline.name,
    application: instance.id, // Platform Instance becomes Application
    team: baseline.createdBy || 'platform-team',
    testType: mapPlatformToTestType(baseline.platform),
    domain: 'platform-config',
    testIds: tests.map(t => t.id),
    description: baseline.description,
    enabled: baseline.isActive,
    baselineConfig: {
      platform: baseline.platform,
      environment: baseline.environment,
      config: baseline.config,
      version: baseline.version,
    },
    runtimeConfig: {
      platformInstance: {
        connection: instance.connection,
      },
      environment: baseline.environment,
    },
    createdAt: baseline.createdAt,
    updatedAt: baseline.updatedAt,
  };
  
  return testSuite;
}
```

**Files to Create:**
- `dashboard-api/src/migrations/baseline-to-test-suite.migration.ts`
- `dashboard-api/src/migrations/run-baseline-migration.ts`

#### 2.2 Instance to Application Converter
**Goal:** Convert Platform Instances to Applications

**Migration Script:**
```typescript
async function migrateInstanceToApplication(
  instance: PlatformInstance,
  baseline: PlatformBaseline
): Promise<Application> {
  const application: Application = {
    id: instance.id,
    name: instance.name,
    description: `Platform Instance: ${instance.name}`,
    team: 'platform-team',
    infrastructure: {
      // Platform-specific infrastructure
      platformInstance: {
        platform: instance.platform,
        connection: instance.connection,
        baselineId: baseline.id, // Reference to Test Suite
      },
    },
    // ... other Application fields
  };
  
  return application;
}
```

**Files to Create:**
- `dashboard-api/src/migrations/instance-to-application.migration.ts`

#### 2.3 Data Migration Execution
**Goal:** Run migration on existing data

**Steps:**
1. [ ] Backup existing baseline and instance data
2. [ ] Run baseline → test suite migration
3. [ ] Run instance → application migration
4. [ ] Validate migrated data
5. [ ] Update references (baselineId → testSuiteId)
6. [ ] Archive old baseline/instance data (keep for rollback)

**Files to Create:**
- `dashboard-api/src/migrations/migrate-all-baselines.ts`
- `dashboard-api/src/migrations/validate-migration.ts`

### Phase 3: Execution Engine Integration (Week 3-4)

#### 3.1 Platform Config Test Executor
**Goal:** Execute platform config tests using existing test framework

**New Executor:**
```typescript
class PlatformConfigTestExecutor {
  async execute(
    test: PlatformConfigTest,
    suite: TestSuite
  ): Promise<TestResult> {
    // 1. Get platform instance connection from suite runtime config
    const connection = suite.runtimeConfig?.platformInstance?.connection;
    
    // 2. Connect to platform API
    const platformClient = await this.connectToPlatform(
      test.platform,
      connection
    );
    
    // 3. Fetch current configuration
    const currentConfig = await platformClient.getConfiguration();
    
    // 4. Get baseline config from suite
    const baselineConfig = suite.baselineConfig?.config || {};
    
    // 5. Evaluate test check expression
    const result = this.evaluateCheck(
      test.check,
      currentConfig,
      baselineConfig
    );
    
    // 6. Return test result
    return {
      testType: test.testType,
      testName: test.name,
      passed: result.passed,
      details: result.details,
      severity: test.severity,
      timestamp: new Date(),
    };
  }
  
  private evaluateCheck(
    check: string,
    current: any,
    baseline: any
  ): { passed: boolean; details: any } {
    // Evaluate expression like "encryption.enabled === true"
    // Compare current config against baseline
    // Return pass/fail with details
  }
}
```

**Files to Create:**
- `heimdall-framework/services/platform-config-tester.ts`
- `heimdall-framework/services/platform-connectors/` (Salesforce, Elastic, etc.)

#### 3.2 Integrate with Test Orchestrator
**Goal:** Platform config tests run through same execution pipeline

**Modifications:**
- [ ] Add platform-config case to `TestOrchestrator.runTest()`
- [ ] Register platform config executor
- [ ] Update test result handling

**Files to Modify:**
- `heimdall-framework/core/test-harness.ts`
- `heimdall-framework/core/test-orchestrator.ts`

### Phase 4: API Unification (Week 4-5)

#### 4.1 Deprecate Baseline APIs
**Goal:** Redirect baseline APIs to test suite APIs

**API Mapping:**
```
GET  /api/v1/{platform}/baselines
  → GET  /api/v1/test-suites?testType={platform}-config

POST /api/v1/{platform}/baselines
  → POST /api/v1/test-suites (with baselineConfig)

GET  /api/v1/{platform}/baselines/:id
  → GET  /api/v1/test-suites/:id

POST /api/v1/{platform}/baselines/:id/validate
  → POST /api/v1/test-suites/:id/run
```

**Implementation:**
- [ ] Create API adapter layer (backward compatibility)
- [ ] Add deprecation warnings
- [ ] Update API documentation

**Files to Create:**
- `dashboard-api/src/baselines/baseline-api-adapter.ts` (temporary)

#### 4.2 Unified Test Execution API
**Goal:** Single API for all test types

**New Endpoints:**
```
POST /api/v1/test-suites/:id/run
  - Runs all tests in suite
  - Works for access-control, platform-config, etc.

GET  /api/v1/test-suites/:id/results
  - Get latest test results
  - Unified result format
```

**Files to Modify:**
- `dashboard-api/src/test-suites/test-suites.controller.ts`
- `dashboard-api/src/test-suites/test-suites.service.ts`

### Phase 5: UI Unification (Week 5-6)

#### 5.1 Update Test Management UI
**Goal:** Platform baselines appear in test management UI

**Changes:**
- [ ] Add platform-config test type filter
- [ ] Show baseline config in test suite details
- [ ] Display platform instance connection info
- [ ] Unified test execution UI

**Files to Modify:**
- `dashboard-frontend/src/views/tests/TestSuites.vue`
- `dashboard-frontend/src/views/tests/TestSuiteDetail.vue`
- `dashboard-frontend/src/components/tests/TestSuiteCard.vue`

#### 5.2 Deprecate Baseline UI
**Goal:** Redirect baseline UI to test management

**Changes:**
- [ ] Add redirects from baseline pages to test suites
- [ ] Show deprecation banner
- [ ] Provide migration guide in UI

**Files to Modify:**
- `dashboard-frontend/src/router/index.ts`
- `dashboard-frontend/src/views/policies/PlatformConfigPolicies.vue`

#### 5.3 Unified Results View
**Goal:** Platform validation results appear with other test results

**Changes:**
- [ ] Extend test results component for platform config
- [ ] Show baseline comparison in results
- [ ] Unified findings/reporting

**Files to Modify:**
- `dashboard-frontend/src/views/tests/TestResults.vue`
- `dashboard-frontend/src/components/tests/TestResultCard.vue`

### Phase 6: Documentation & Cleanup (Week 6-7)

#### 6.1 Update Documentation
**Goal:** Document unified model

**Documents to Update:**
- [ ] Test Creation Guide (add platform-config examples)
- [ ] API Documentation (unified endpoints)
- [ ] User Guide (platform validation via tests)
- [ ] Migration Guide (for existing baseline users)

**Files to Modify:**
- `docs/guides/TEST_CREATION_GUIDE.md`
- `docs/guides/USER_GUIDE.md`
- `dashboard-api/docs/api/TESTING.md`

#### 6.2 Remove Baseline Code
**Goal:** Clean up old baseline implementation

**Files to Remove:**
- [ ] `dashboard-api/src/baselines/` (after migration)
- [ ] `dashboard-api/src/platform-config/` (after migration)
- [ ] `dashboard-api/src/{platform}-baselines/` (after migration)
- [ ] Baseline-specific UI components

**Timeline:** After 3-month deprecation period

## Implementation Details

### Test Type Mapping

| Platform | Baseline Type | Test Type | Domain |
|----------|---------------|-----------|--------|
| Salesforce | Config | `salesforce-config` | `platform-config` |
| Salesforce | Security | `salesforce-security` | `platform-security` |
| Elastic | Config | `elastic-config` | `platform-config` |
| Elastic | Security | `elastic-security` | `platform-security` |
| IDP/K8s | Compliance | `idp-compliance` | `platform-security` |
| ServiceNow | Config | `servicenow-config` | `platform-config` |

### Validation Rule to Test Conversion

**Before (Baseline Validation Rule):**
```typescript
{
  check: "encryption.fieldEncryption.enabled === true",
  severity: "critical",
  autoGenerated: true
}
```

**After (Platform Config Test):**
```typescript
{
  id: "test-123",
  name: "Field Encryption Enabled",
  testType: "salesforce-config",
  domain: "platform-config",
  platform: "salesforce",
  check: "encryption.fieldEncryption.enabled === true",
  severity: "critical",
  autoGenerated: true,
  configPath: "encryption.fieldEncryption.enabled"
}
```

### Baseline Config Storage

**In Test Suite:**
```typescript
{
  baselineConfig: {
    platform: "salesforce",
    environment: "production",
    config: {
      encryption: {
        fieldEncryption: { enabled: true },
        platformEncryption: { enabled: true }
      },
      // ... full baseline config
    },
    version: "1.0"
  }
}
```

## Migration Checklist

### Pre-Migration
- [ ] Backup all baseline and instance data
- [ ] Document current baseline usage
- [ ] Identify all baseline references in code
- [ ] Create rollback plan

### Migration Execution
- [ ] Run baseline → test suite migration
- [ ] Run instance → application migration
- [ ] Validate migrated data integrity
- [ ] Test migrated test suites execution
- [ ] Verify API compatibility layer

### Post-Migration
- [ ] Update all documentation
- [ ] Train team on new model
- [ ] Monitor for issues
- [ ] Plan deprecation timeline for old APIs

## Rollback Plan

If migration fails:
1. Restore baseline/instance data from backup
2. Revert code changes
3. Restore old API endpoints
4. Document issues for next attempt

## Success Criteria

1. ✅ All platform baselines converted to test suites
2. ✅ All platform instances converted to applications
3. ✅ Platform validation executes through test framework
4. ✅ Results appear in unified test results view
5. ✅ No data loss during migration
6. ✅ Backward compatibility maintained (via adapter)
7. ✅ Documentation updated
8. ✅ Team trained on new model

## Timeline

| Phase | Duration | Dependencies |
|-------|----------|--------------|
| Phase 1: Data Model Alignment | 2 weeks | None |
| Phase 2: Migration Scripts | 1-2 weeks | Phase 1 |
| Phase 3: Execution Engine | 1-2 weeks | Phase 1 |
| Phase 4: API Unification | 1 week | Phase 2, 3 |
| Phase 5: UI Unification | 1-2 weeks | Phase 4 |
| Phase 6: Documentation | 1 week | Phase 5 |
| **Total** | **7-10 weeks** | |

## Risks & Mitigation

### Risk 1: Data Loss During Migration
**Mitigation:** Comprehensive backups, validation scripts, rollback plan

### Risk 2: Breaking Changes for Users
**Mitigation:** API adapter layer, deprecation period, migration guide

### Risk 3: Performance Impact
**Mitigation:** Test execution performance, optimize platform connectors

### Risk 4: Complexity of Platform Connectors
**Mitigation:** Incremental implementation, test each platform separately

## Next Steps

1. **Review & Approve Plan** - Get stakeholder approval
2. **Create Migration Branch** - Isolate migration work
3. **Start Phase 1** - Begin data model alignment
4. **Weekly Check-ins** - Track progress and adjust as needed

## Questions & Decisions Needed

1. **Timeline:** Is 7-10 weeks acceptable?
2. **Backward Compatibility:** How long should adapter layer remain?
3. **Test Execution:** Should platform tests run in CI/CD automatically?
4. **UI:** Keep separate baseline UI or fully migrate to test UI?
5. **Naming:** Keep "baseline" terminology or fully adopt "test suite"?

---

**Document Version:** 1.0  
**Last Updated:** 2026-01-24  
**Author:** AI Assistant  
**Status:** Draft - Pending Review
